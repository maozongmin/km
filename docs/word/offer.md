# 常见问题

## 技术 - 前端知识

-   <b>dom 树节点和渲染树节点一一对应吗，有什么是 dom 树会有，渲染树不会有的节点?</b>

    在 DOM 树构建的同时，浏览器会构建渲染树（render tree）。渲染树的节点（渲染器），在 Gecko 中称为 frame，而在 webkit 中称为 renderer。渲染器是在文档解析和创建 DOM 节点后创建的，会计算 DOM 节点的样式信息。

    在 webkit 中，renderer 是由 DOM 节点调用 attach()方法创建的。attach()方法计算了 DOM 节点的样式信息。attach()是自上而下的递归操作。也就是说，父节点总是比子节点先创建自己的 renderer。销毁的时候，则是自下而上的递归操作，也就是说，子节点总是比父节点先销毁。

    如果元素的 display 属性被设置成了 none，或者如果元素的子孙继承了 display:none，renderer 不会被创建。节点的子类和 display 属性一起决定为该节点创建什么样的渲染器。但是 visibility：hidden 的元素会被创建。

    在 webkit 中，根据 display 属性的不同，创建不同的 renderer，比如：

    (1) display:inline，创建的是 RenderInline 类型。

    (2) display:block，创建的是 RenderBlock 类型。

    (3) display:inline-block，创建的是 RenderBlock 类型。

    (4) display:list-item，创建的是 RenderListItem 类型。

    position:relative 和 position:absolute 的元素在渲染树中的位置与 DOM 节点在 DOM 树中的位置是不一样的。

    DOM 树和渲染树的对应关系如下图：

    <img src="../.vuepress/public/img/20140224185057296.jpg"/>

-   <b>CSS 会阻塞 dom 解析吗？</b>

    ```
    浏览器是解析DOM生成DOM Tree，结合CSS生成的CSS Tree，最终组成render tree，再渲染页面。在此过程中CSS完全无法影响DOM Tree，因而无需阻塞DOM解析。

    CSS 不会阻塞 DOM 的解析，但会阻塞 DOM 渲染。

    css加载会阻塞后面js语句的执行

    js会阻塞DOM树的解析，也会阻塞DOM树的渲染，但浏览器会"偷看"DOM，预先下载相关资源。

    浏览器遇到 <script>且没有 defer 或 async 属性的 标签时，会触发页面渲染，因而如果前面 CSS 资源尚未加载完毕时，浏览器会等待它加载完毕在执行脚本。

    所以，你现在明白为何<script>最好放底部，<link>最好放头部，如果头部同时有<script>与<link>的情况下，最好将<script>放在<link>上面
    ```

-   requestIdleCallback 是干什么用的？  
    1 秒 60 帧不卡，所以 1 帧时间在 16.6ms 内完成， = 1000ms / 60fps = 16.6ms;

    1 帧需要做的事情：

    -   处理用户的交互
    -   JS 解析执行
    -   帧开始。窗口尺寸变更，页面滚动等的处理
    -   requestAnimationFrame(rAF)
    -   布局
    -   绘制

    当关注用户体验，不希望因为一些不重要的任务（如统计上报）导致用户感觉到卡顿的话，就应该考虑使用 requestIdleCallback。因为 requestIdleCallback 回调的执行的前提条件是当前浏览器处于空闲状态。

    requestAnimationFrame 的回调会在每一帧确定执行，属于高优先级任务，而 requestIdleCallback 的回调则不一定，属于低优先级任务。

-   浏览器的渲染原理及流程

    1. 根据 html 文件构建 DOM 树和 CSSOM 树。构建 DOM 树期间，如果遇到 JS，阻塞 DOM 树及 CSSOM 树的构建，优先加载 JS 文件，加载完毕，再继续构建 DOM 树及 CSSOM 树。

    2. 构建渲染树（Render Tree）。

    3. 页面的重绘（repaint）与重排（reflow，也有称回流）。页面渲染完成后，若 JS 操作了 DOM 节点，根据 JS 对 DOM 操作动作的大小，浏览器对页面进行重绘或是重排。

*   关键渲染路径详述

    ```
    处理 HTML 标记并构建 DOM 树。
    处理 CSS 标记并构建 CSSOM 树。
    将 DOM 与 CSSOM 合并成一个渲染树。
    根据渲染树来布局，以计算每个节点的几何信息。
    将各个节点绘制到屏幕上。
    ```

*   避免回流的方式
    1. 不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className，即将多次改变样式属性的操作合并成一次操作：
        ```
        // 不好的写法
        var left = 10,
        top = 10;
        el.style.left = left + "px";
        el.style.top  = top  + "px";
        el.style.background = '#eee';
        // 比较好的写法
        el.className += " theclassname";
        ```
    2. 让要操作的元素进行”离线处理”，处理完后一起更新
        - 使用 DocumentFragment 进行缓存操作,引发一次回流和重绘；
        - 使用 display:none 技术，只引发两次回流和重绘;
          原理：由于 display 属性为 none 的元素不在渲染树中，对隐藏的元素操 作不会引发其他元素的重排。如果要对一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发 2 次重排。
        - 使用 cloneNode(true or false) 和 replaceChild 技术，引发一次回流和重绘；
    3. 不要把 DOM 节点的属性值放在一个循环里当成循环里的变量。不然这会导致大量地读写这个结点的属性。
    4. 尽可能的修改层级比较低的 DOM 节点。当然，改变层级比较底的 DOM 节点有可能会造成大面积的 reflow，但是也可能影响范围很小。
       因为改变 DOM 树中的一级会导致所有层级的改变，上至根部，下至被改变节点的子节点。这导致大量时间耗费在执行 reflow 上面
    5. 将需要多次重排的元素，position 属性设为 absolute 或 fixed，这样此元素就脱离了文档流，它的变化不会影响到其他元素为动画的 HTML 元素，例如动画，那么修改他们的 CSS 是会大大减小 reflow 。因为,它们不影响其他元素的布局，所它他们只会导致重新绘制，而不是一个完整回流。这样消耗会更低。
    6. 。不要用 tables 布局的一个原因就是 tables 中某个元素一旦触发 reflow 就会导致 table 里所有的其它元素 reflow。在适合用 table 的场合，可以设置 table-layout 为 auto 或 fixed，这样可以让 table 一行一行的渲染，这种做法也是为了限制 reflow 的影响范围。
    7. 避免使用 CSS 的 JavaScript 表达式，如果 css 里有 expression，每次都会重新计算一遍。

-   跨域的方式
    -   跨域：当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域。
    -   解决方案：
        1. jsonp：缺点是仅支持 get 方法具有局限性,不安全可能会遭受 XSS 攻击。
        2. cors：服务端设置 Access-Control-Allow-Origin 就可以开启 CORS
        3. postMessage：
            - 页面和其打开的新窗口的数据传递
            - 多窗口之间消息传递
            - 页面与嵌套的 iframe 消息传递
        4. WebSocket：Websocket 是 HTML5 的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket 和 HTTP 都是应用层协议，都基于 TCP 协议。但是 WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。
        5. Node 中间件代理(两次跨域)：同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。
        6. nginx 反向代理：通过 nginx 配置一个代理服务器做跳板机，反向代理访问 domain2 接口，并且可以顺便修改 cookie 中 domain 信息，方便当前域 cookie 写入，实现跨域登录。
        7. window.name + iframe
        8. location.hash + iframe
        9. document.domain + iframe
-   前端的网络安全如何防御（xss，csrf）
    -   XSS 的根源主要是没完全过滤客户端提交的数据 ，所以重点是要过滤用户提交的信息。
        1. 将重要的 cookie 标记为 http only, 这样的话 js 中的 document.cookie 语句就不能获取到 cookie 了.
        2. 只允许用户输入我们期望的数据。例如：age 用户年龄只允许用户输入数字，而数字之外的字符都过滤掉。
        3. 对数据进行 Html Encode 处理： 用户将数据提交上来的时候进行 HTML 编码，将相应的符号转换为实体名称再进行下一步的处理
        4. 过滤或移除特殊的 Html 标签， 例如: `<script>, <iframe> , < for <, > for >, &quot for`
        5. 过滤 js 事件的标签。例如 "onclick=", "onfocus" 等等。
    -   防止 CSRF 的解决方案
        1. 重要数据交互采用 POST 进行接收，当然是用 POST 也不是万能的，伪造一个 form 表单即可破解。
        2. 使用验证码，只要是涉及到数据交互就先进行验证码验证，这个方法可以完全解决 CSRF。但是出于用户体验考虑，网站不能给所有的操作都加上验证码。因此验证码只能作为一种辅助手段，不能作为主要解决方案。
        3. 验证 HTTP Referer 字段，该字段记录了此次 HTTP 请求的来源地址，最常见的应用是图片防盗链。
        4. 为每个表单添加令牌 token 并验证
    -   防止 SQL 注入的解决方案
        1. 对用户的输入进行校验，使用正则表达式过滤传入的参数
        2. 使用参数化语句，不要拼接 sql，也可以使用安全的存储过程
        3. 不要使用管理员权限的数据库连接，为每个应用使用权限有限的数据库连接
        4. 检查数据存储类型
        5. 重要的信息一定要加密
-   cookies 的保护方式

    优先使用渲染层合并属性、控制层数量

    对用户输入事件的处理函数去抖动（移动设备）

-   浏览器的缓存机制

-   什么文件用强缓存，什么文件用协商缓存

-   React-Native 的原理，优缺点

-   react 的虚拟 dom 和 diff 描述

-   react 渲染优化（class，hook）

-   react 的 context 的使用场景

-   node 和后端知识

-   mysql 和 mongo 的区别，使用情景

-   node 有什么情况会导致内存溢出

    -   在 Node 中通过 JavaScript 使用内存时只能使用部分内存（64 位系统：1.4 GB，32 位系统：0.7 GB），这个时候，如果前端项目非常的庞大，Webpack 编译时就会占用很多的系统资源，如果超出了 V8 引擎对 Node 默认的内存限制大小时，就会产生内存泄露(JavaScript heap out of memory)的错误。

-   node 的内存分配

-   event loop（浏览器和 node）

-   首屏优化方案

-   在 App 中如何实现前端资源离线缓存（方案）

## 二

晚上，视频面试，属于其他部门同事。

前端知识

浏览器的输入 url 后的过程

js 异步方式

promise.resolve 是干嘛的

promise.then 如何实现链式调用

promise.then 不返还一个 promise 还能用 then 吗

promise.finally 的作用，如何自己实现 finally

promise 原理

webpack 的异步加载如何实现

webpack 的分包策略

跨域方式有什么

jsonp 的原理

csrf 防御手段

cookie 的 samesite 属性作用

js 对象循环引用会导致什么问题

react 如何阻止原生默认事件

react 的 fiber 节点树是什么数据结构，为什么要用这样的数据结构

react 异步渲染原理，优先级如何划分

react hook 有自己做一些自定义的 hook 吗

react key 的原理

react 如何实现函数式调用组件，toast.show()

react 新增了什么生命周和删除了什么生命周期，为什么要删除

node 后端知识

node 对于 option 请求如何处理

node 如何处理 cors 跨域

ES modules 和 commonjs 的区别

node 的 event loop 和浏览器的区别

dns 查询过程，dns 用什么协议发起 dns 查询的

tcp 和 udp 区别

tcp 的三次握手和四次挥手

协商缓存和强缓存的区别

-   https 协议握手大概过程

    -   客户端发送请求到服务器端
    -   服务器端返回证书和公开密钥，公开密钥作为证书的一部分而存在
    -   客户端验证证书和公开密钥的有效性，如果有效，则生成共享密钥并使用公开密钥加密发送到服务器端
    -   服务器端使用私有密钥解密数据，并使用收到的共享密钥加密数据，发送到客户端
    -   客户端使用共享密钥解密数据
    -   SSL 加密建立………

-   https 证书的作用

    -   https 很好的解决了 http 的三个缺点（被监听、被篡改、被伪装）

-   如何埋点，为什么用 1\*1 像素的 gif 图片做上报
    -   能够完成整个 HTTP 请求+响应（尽管不需要响应内容）
    -   触发 GET 请求之后不需要获取和处理数据、服务器也不需要发送数据
    -   跨域友好
    -   执行过程无阻塞
    -   相比 XMLHttpRequest 对象发送 GET 请求，性能上更好
    -   GIF 的最低合法体积最小（最小的 BMP 文件需要 74 个字节，PNG 需要 67 个字节，而合法的 GIF，只需要 43 个字节）

如何定义首屏

算法

// 从扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这 5 张牌是不是连续的。2 ～ 10 为数字本身，A 为 1，J 为 11，Q 为 12，
K 为 13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。

// 示例 1:

// 输入: [1,2,3,4,5]

// 输出: True

// 示例 2:

// 输入: [0,0,1,2,5]

// 输出: True

// 限制：

// 数组长度为 5

// 数组的数取值为 [0, 13] .

## 三

早上，视频面试，leader 面试

前端知识

绑定事件有多少种方式

事件触发的流程，捕获和冒泡

捕获阶段能终止吗

终止冒泡阶段有哪些

如果实现 one 绑定事件

事件委托的原理

event.target 和 event.currtager 的区别

浏览器显示一个图片有什么方式

如何获取 url 中的?后的参数

浏览器的内存回收机制 标记清除还是引用计数？

如何解决跨域

什么是简单请求什么复杂请求

const 和 let 有什么区别

ES6 常用的 api 有哪些

数组断引用的方式有什么

-   Base64 图片有什么问题
    -   根据 base64 的编码原理，大小比原文件大小大 1/3
    -   HTML 文件本身尺寸会变大，会影响首屏加载
    -   base64 无法缓存，要缓存只能缓存包含 base64 的文件，比如 HTML 或者 CSS，这相比直接缓存图片要弱很多，一般 HTML 会改动频繁，所以等同于得不到缓存效益

node 后端知识

Http 强缓存和协商缓存用的是什么字段，整体流程是怎样

Https 原理

Https 第一次请求会携带什么

-   Ca 证书的内容是什么

    -   CA 是 Certificate Authority 的缩写，也叫“证书授权中心”。

-   二进制分帧的具体是什么
    -   在二进制分帧层上，HTTP 2.0 会将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码 ，其中 HTTP1.x 的首部信息会被封装到 Headers 帧，而我们的 request body 则封装到 Data 帧里面。然后，HTTP 2.0 通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流。相应地，每个数据流以消息的形式发送，而消息由一或多个帧组成，这些帧可以乱序发送，然后再根据每个帧首部的流标识符重新组装。
    -   HTTP 2.0 新增的一个强大的新功能，就是服务器可以对一个客户端请求发送多个响应。
    -   HTTP2.0 所有通信都是在一个 TCP 连接上完成。

Keep alive 和多路复用的区别

Option 请求的作用

Node gc 方式

-   新生代和老生代的区别

    -   新生代的内存被一分为二，这两块小地盘都叫 semispace 空间，这俩小地盘只有一个处于使用中，另一个处于闲置状态，而处于使用中的叫 From 空间， 闲置的叫 To 空间；
    -   老生代的中存放的数据垃圾回收主要采用标记清除(Mark-Sweep)和标记整理(Mark-Compact)。v8 会给还存活的对象打上标记，然后把没有标记的对象全部清除，这就是一次标记清除；

-   新生代内存地址移动到老生代内存地址的过程
    -   在复制过程中会检查对象的内存地址来判断这个对象是否已经经历过一次 Scavenge 回收，如果这个对象已经经历过一次了，这个对象就会被放到老生代里或者如果 To 空间的使用量已经到达 25%，这个对象也会直接升入老生代；

开放问题

长列表优化方案

-   首屏优化方案

    1. CDN 分发（减少传输距离）
    2. 后端在业务层的缓存。数据库查询缓存是可以设置缓存的
    3. 静态文件缓存方案。这个最常看到。现在流行的方式是文件 hash+强缓存的一个方案。比如 hash+ cache control: max-age=1 年。
    4. 前端的资源动态加载：
        - 路由动态加载，最常用的做法，以页面为单位，进行动态加载。
        - 组件动态加载(offScreen Component)，对于不在当前视窗的组件，先不加载。
        - 图片懒加载(offScreen Image)
    5. 减少请求的数量
    6. 页面使用骨架屏。意思是在首屏加载完成之前，通过渲染一些简单元素进行占位。
    7. 使用 ssr 渲染。
    8. 引入 http2.0。http2.0 对比 http1.1，最主要的提升是传输性能，在接口小而多的时候会更加明显。
    9. 利用好 http 压缩。最普通的 gzip,另外，接口也是能压缩的。
    10. 利用好 script 标签的 async 和 defer 这两个属性。功能独立且不要求马上执行的 js 文件，可以加入 async 属性。如果是优先级低且没有依赖的 js，可以加入 defer 属性。
    11. 选择先进的图片格式。使用 WebP 的图片格式来代替现有的 jpeg 和 png
    12. 渲染的优先级。浏览器有一套资源的加载优先级策略。也可以通过 js 来自己控制请求的顺序和渲染的顺序。一般我们不需要这么细粒度的控制，而且控制的代码也不好写。
    13. 前端做一些接口缓存。前端也可以做接口缓存，缓存的位置有两个，一个是内存，即赋值给运行时的变量，另一个是 localStorage。或者有个列表页，我们总是缓存上次的列表内容到本地，下次加载时，我们先从本地读取缓存，并同时发起请求到服务器获取最新列表。
    14. lightHouse 是 chorme devTools 的一个功能，经常用来检查首屏加载的情况，它提供的建议也很有用。它给出的是通用性的一些建议，如果想进一步优化，需要结合业务本身的特点进行定制优化。

Node 如何保证第三方接口的稳定性

## 四

浏览器从写入 url 到加载完毕的流程

-   浏览器白屏原因

    1. 在弱网络下(2G 网路或者 GPRS 网络) ,网络延迟，JS 加载延迟 ,会阻塞页面
    2. 客户端存在 bug，缓存模块错乱，不缓存 js 等后来挂起的文件，以及乱缓存 index.html
    3. 前置接口调用时间过长
    4. 首页直出时间过长

-   浏览器白屏解决方案
    1. 需要使用 nodejs 直出了，通过在服务端增加一个 nodejs 中间层，由 nginx 将前端的请求转发到 nodejs 上，nodejs 响应请求，加载资源，向底层的 cgi 进行 API 请求，之后进行拼接，返回 html 页面，这样资源跟 api 的请求时间都在服务端完成，缩短了时间，至于模板之类的，还是能够用到前端。当然 nodejs 也会有请求资源错误的情况，这个时候就需要返回错误标志给前端，前端再发起原来的异步请求，这种方式相当于一种容灾保障。
    2. 强烈按照“首页必须”进行开发，按需加载，其他的资源可以放在二屏
    3. 尽量减少文件夹的嵌套，文件名不要过长
    4. 接口调用时间过长也会导致单页面应用的加载时间过长，这种我们主要是前端需要给接口设置 timeout
    5. 缓存，判断服务器版本是否与客户端保存的资源一致，不一致即下载新的，一致即直接使用本地的，这样就变成一个类本地应用了。

页面打开后 cpu 和内存快速增长，如何定位问题，可能有什么问题

长列表优化，以及长列表中，如果带搜索功能如何实现

## 五

最新规定 9 级及以上级别需要 1-5 轮的技术委员会进行加面。

为什么使用 RN

有 100 匹马，场地只有 4 条跑道，得出最快的 4 只马需要多少轮 Lam：100 匹马，4 个赛道，找出跑最快的 4 匹马。

已知函数 fn1 会随机返回 1-5 的整数，要求基于 fn1 编写 fn2，要随机生成 1-7，fn2 内不能使用系统的随机 api，只能调用
fn1 获取随机数

## 六

-   前端的未来发展的一些思考
    -   领域从传统 web 前端，到服务端（nodejs），到移动端（rn,weex），再到桌面(electron)；webgl,flutter,go
-   Serverless 的优缺点，前端的应用范围

    -   Serverless 优势：

        1. 构建和部署更简单；
        2. 使扩展成本最小化；
        3. 降低运维成本；
        4. 提高开发效率。
        5. 主要由 Baas（backend as a services）和 Faas（function as a services）

    -   Serverless 劣势：

        1. 重复的函数逻辑，函数量多；
        2. 无状态，不适合有状态复杂场景；
        3. 冷启动慢&高延迟；
        4. 工具链（调试、开发、日志工具等）缺乏。

    -   Serverless 适用业务场景：

        1. 多媒体处理；
        2. 数据库更改或更改数据捕获（CDC）；
        3. IOT/物联网传感器输入消息；
        4. 大规模流处理；
        5. 批处理作业或计划任务；
        6. HTTP REST API 和 Web 应用程序；
        7. 移动后端；
        8. 持续集成管道；
        9. 机器学习及 AI 模型处理；
        10. 图片处理；
        11. 聊天机器人。

页面性能优化

做过的专项的架构图

## 七

你现在公司最有成就感的项目是什么

你现在公司最有挑战的项目是什么，你是如果解决难题的

现在前端除了一些基本的面试知识外，明显感觉到算法的考虑在逐步加强，所以也总结一些重点的考点吧。一些很基本的
原理我就不写了，什么闭包，什么原型链

对 JavaScript 的 Api 可以手写。

bind

new

promise

.....

浏览器的加载原理，回流重绘，url 输入后的流程，关键渲染路径等....

框架的原理，了解你最常用的框架的内部原理以及实现，包括思想等。

浏览器和 node 的 GC 原理

浏览器和 node 之间 eventLoop 的区别

webpack 的基本原理

数据库，redis，nginx 的一些基本概念以及基本原理和优化。

对于前端页面的优化方案，包括首屏加载，资源整合，网络优化，长列表优化等

网络安全，xss，csrf，cookies 保护等

网络知识

tcp

https 和 http

dns

udp

算法和数据结构

基本常用排序

链表操作

树结构操作

贪心算法

回溯算法

双指针操作

哈希表

动态规划（一般为加分题）
